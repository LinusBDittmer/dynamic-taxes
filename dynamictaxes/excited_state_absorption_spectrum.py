'''

Class for the Excited State Absorption Spectrum

This class serves as a container for all ESA data as well as a wrapper for the image generation and utility functions.

'''

import numpy
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.colors as colours
import json
import re
import os
import dynamictaxes as dt


class ExcitedStateAbsorptionSpectrum:
    '''
    This class is used to store required attributes of Excited State Absorption (ESA) Spectra as well as contain the methods required for rendering and utilities.

    Attributes
    ----------
    state_num : int
        Number of the state from which the excitation happens. 0 is the ground state
    multiplicity : int
        Multiplicity of the state from which the excitation happens. We follow 2n+1 convention, i. e. a singlet is multiplicity 1
    energies : ndarray
        Array of excitation energies.
    energy_unit : str
        Unit of energy in which the energies are given. Default: ev, recommended not to change
    transition_moments : ndarray
        Array of transition moments. Note that this has to have the exact same shape as energies
    excited_state_labels : str
        Labels of excited states for rendering purposes
    peak_breadth : float
        Breadth of drawn Gaussians in nm. Loaded from default.config
    resolution : int
        Number of points considered on the x-axis. Loaded from default.config
    dpi : int
        DPI of image generated by render(...). Loaded from default.config
    wavelength_range : float, float
        List of two floats. Bounds of the rendered wavelengths in nm. Loaded from default.config
    normalise_peakheight : bool
        Whether the peak height should be normalised for the highest point in the graph to be 1.0. Loaded from default.config
    peak_style : str
        The style in which individual excitations are to be drawn. Note that you can activate multiple styles by concatenating them with commata. Allowed styles are 'bar' and 'gauss'. Loaded from default.config
    linegraph_size : float, float
        Tuple of two floats, giving width and height of the ESA spectrum in inches. Loaded from default.config

    Methods
    -------
    render(path, filetype='png')
        Renders the ESA spectrum to the given path and creates required folders.
    evaluate(nm)
        Returns the absorption intensity at the given wavelength
    col(nm)
        Returns the spectral colour of the given wavelength
    gaussian(xvals, centre, height)
        Evaluates a gaussian with defined centre and height at the given xvals
    get_multiplicity_label(m)
        Returns the character label of a number mulitplicity
    reformat_state_label(l)
        Reformats the given state label into LaTeX appropriate markdown.
    '''

    def __init__(self):
        self.state_num = 0
        self.multiplicity = 1
        self.time = 0
        self.energies = numpy.zeros(1)
        self.energy_unit = dt.get_config("energy_unit")
        self.transition_moments = numpy.zeros(1)
        self.excited_state_labels = ["S1"]
        self.peak_breadth = dt.get_config("peak_breadth")
        self.resolution = dt.get_config("wavelength_res")
        self.dpi = dt.get_config("dpi")
        self.wavelength_range = [dt.get_config("wavelength_range_lower"), dt.get_config("wavelength_range_upper")]
        self.normalise_peakheight = dt.get_config("normalise_peak_height")
        self.peak_style = dt.get_config("peak_style")
        self._cmap = matplotlib.colormaps['Spectral']
        self._norm = colours.Normalize(vmin=350, vmax=820, clip=False)
        self.linegraph_size = (dt.get_config("linegraph_width"), dt.get_config("linegraph_height"))

    def __eq__(self, other):
        if len(self.energies) != len(other.energies):
            return False
        for i in range(len(self.energies)):
            if abs(self.energies[i] - other.energies[i]) > 10**-7:
                return False
            if abs(self.transition_moments[i] - other.transition_moments[i]) > 10**-7:
                return False
        return True

    def render(self, path, filetype='png'):
        '''
        Principal method of the ESA class. Renders the ESA spectrum to the given path with given filetype. If the directory of the path or parent directories thereof are not existant, they are created. Similarly, if the path already contains a file ending, the filetype attribute is ignored. Otherwise, it is added.

        Parameters
        ----------
        path : str
            The file name and path to wich the image should be rendered.
        filetype : str, optional
            The file ending. Default png

        '''
        filepattern = re.compile("[a-zA-Z0-9\-]*\." + filetype)
        match1 = filepattern.match(path)
        add_filetype = match1 is None
        if not add_filetype:
            add_filetype = match1.string != path
        if not add_filetype:
            filepattern2 = re.compile("[a-zA-Z0-9\-]*\.")
            match2 = filepattern2.match(path)
            add_point = match is None
            if not add_point:
                add_point = match2.string != path
            if add_point:
                path += "."
            path += filetype
        directory = path[:path.rfind("/")]
        os.makedirs(directory, exist_ok=True)

        wavelength_space = numpy.linspace(self.wavelength_range[0], self.wavelength_range[1], num=self.resolution)
        norm_tm = numpy.copy(self.transition_moments)
        if self.normalise_peakheight:
            norm_tm /= numpy.amax(norm_tm)
        
        plt.figure()
        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=self.linegraph_size)
       
        ax.margins(x=0, y=0)
        ax.set_xlim(self.wavelength_range[0], self.wavelength_range[1])
        ax.set_xlabel("Wavelength [nm]")
        ax.set_ylabel("Rel. Transition Moment")
        gaussians = numpy.zeros((len(self.energies), self.resolution))
        for i in range(len(gaussians)):
            nm = 1239.841 / self.energies[i]
            gaussians[i] = self.gaussian(wavelength_space, nm, norm_tm[i])

        absorption = numpy.sum(gaussians, axis=0)
        ax.set_ylim(0.0, numpy.amax(absorption)*1.1)

        peak_styles = [s.strip() for s in self.peak_style.split(",")]
        for i, g in enumerate(gaussians):
            gc = self.col(1239.841 / self.energies[i])
            label = self.get_multiplicity_label(self.multiplicity) + "$_" + str(self.state_num) + " \\rightarrow$ " + self.reformat_state_label(self.excited_state_labels[i]) 
            if 'gauss' in peak_styles or 'band' in peak_styles:
                gc = list(gc)
                gc[3] = 0.5
                gc = tuple(gc)
                ax.plot(wavelength_space, g, c=gc, label=label)
            if 'bar' in peak_styles:
                ax.vlines(1239.841 / self.energies[i], 0, norm_tm[i], colors=[gc], label=label)

        for i in range(self.resolution-1):
            xs = wavelength_space[i:i+2]
            ys = absorption[i:i+2]
            ci = i * (self.wavelength_range[1] - self.wavelength_range[0]) / self.resolution + self.wavelength_range[0]
            ax.plot(xs, ys, c=self.col(ci))

        plt.legend()
        plt.savefig(path, dpi=self.dpi, bbox_inches='tight')
        plt.close()

    def _eval_scalar(self, nm):
        val = 0.0
        for i in range(len(self.energies)):
            val += self.gaussian(nm, 1239.841 / self.energies[i], self.transition_moments[i])
        return val

    def evaluate(self, nm):
        '''
        This function returns the spectral intensity at a given array of wavelengths. If only one wavelength is given, this is rerouted to _eval_scalar.

        Parameters
        ----------
        nm : float or ndarray
            The wavelength or 1D ndarray of wavelengths at which the spectrum is to be evaluated. 

        Returns
        -------
        ints : float or ndarray
            The intensity or 1D ndarray thereof at the given wavelength or wavelengths.

        '''
        if type(nm) is not numpy.ndarray:
            return self._eval_scalar(nm)
        val = numpy.zeros(len(nm))
        for i in range(len(self.energies)):
            val += self.gaussian(nm, 1239.841 / self.energies[i], self.transition_moments[i])
        return val

    def col(self, nm):
        '''
        This function returns the colour of a given wavelength as an RGBA tuple. If the given wavelength is outside the visible range, black is returned.

        Parameters
        ----------
        nm : float
            Wavelength at which the colour is to be evlauated.

        Returns
        -------
        col : ndarray
            RGBA style ndarray with shape (4,) that contains the colour of the wavelength or black if invisible.
        '''
        n = self._norm(nm)
        black = numpy.array([0.0, 0.0, 0.0, 1.0])
        if n < 0 or n > 1:
            return black
        else:
            return self._cmap(n)

    def gaussian(self, xvals, centre, height):
        '''
        This function evaluates a Gaussian at the given xvals. The gaussian has a centre point centre and a height at that centre of height.

        Parameters
        ----------
        xvals : float or ndarray
            The (multiple) wavelengths in nm at which the Gaussian is to be constructed.
        centre : float
            The wavelength of maximum intensity in nm.
        height : float
            The height of the Gaussian at the point centre.

        Returns
        -------
        ints : float or ndarray
            The calculated intensities.
        '''
        adjusted_xvals = (xvals - centre) / self.peak_breadth
        ep_val = - 2*adjusted_xvals*adjusted_xvals
        return numpy.exp(ep_val) * height

    def get_multiplicity_label(self, m):
        '''
        This function returns the multiplicity label for a given multiplicity.

        Parameters
        ----------
        m : int
            The multiplicity. The values 1, 2, 3, 4 are allowed.

        Returns
        -------
        label: str
            The corresponding 1-letter label.
        '''
        return ["", "S", "D", "T", "Q"][int(m)]

    def reformat_state_label(self, l):
        '''
        Reformats the state label into LaTeX-appropriate markdown. For example, S1 becomes S$_1$ to put the number in the index.

        Parameters
        ----------
        l : str
            Two letter state label

        Returns
        -------
        rl : str
            Reformatted label.
        '''
        return l[0] + "$_" + l[1] + "$"


if __name__ == '__main__':
    esa = ExcitedStateAbsorptionSpectrum()
    esa.energies = numpy.linspace(2.0, 4.0, 4)
    esa.transition_moments = numpy.linspace(0.1, 0.5, 4)
    esa.excited_state_labels = ["S2", "S3", "T1", "S4"]
    esa.render('test.png')
